{"name":"Scala-mas","tagline":"","body":"# scala-mas\r\n\r\n[![Build Status](https://travis-ci.org/ParaPhraseAGH/scala-mas.svg)](https://travis-ci.org/ParaPhraseAGH/scala-mas)\r\n\r\nA Lightweight parallel Multi-Agent System library in Scala.\r\nThe goal of this project is to help creating highly-concurrent multi-agent systems targeted at massively multicore hardware.\r\n\r\nThis project allows to design a computationally-intensive multi-agent system decoupled from the runtime environment.\r\nThen, different runtime components can be chosen to run the simulation in the most efficient settings for a given hardware.\r\n\r\n### Motivation\r\n\r\nWriting a concurrent application is hard for most programmers. Writing a concurrent agent simulation is even harder.\r\nMoreover, most of the existing software tighly couples the agent programming model to the underlying execution model and parallelism type.\r\n\r\nWe want programmers to be able to design a multi-agent system at a high level which abstracts of the actual execution model.\r\nThen, such high level multi-agent patterns could be mapped to match a specific hardware by using the most adequate execution model for that hardware.\r\n\r\nAs a result, multi-agent simulations and computations could be easily designed and tested and the same design could then be scaled out along with\r\nadditional resources to solve harder problems or run bigger simulations.\r\n\r\n## Instalation\r\n\r\nYou can find published releases on Maven Central.\r\n\r\n#### Project structure\r\n\r\nThe project is structures into the following modules:\r\n\r\n- **core**- APIs for designing a MAS, as well as two execution backends: a synchronous and asynchronous one.\r\n- **emas** - A example MAS application for evolutionary optimization.\r\n- **genetic** - Genetic operators' APIs for evolutionary optimization.\r\n- **examples** - An example of how to compose and run an EMAS application.\r\n\r\nIn order to grab all the modules, add the following lines to your build configuration:\r\n\r\n#### Sbt\r\n    resolvers += Resolver.sonatypeRepo(\"snapshots\")\r\n\r\n    libraryDependencies += \"pl.edu.agh.scalamas\" % \"emas\" % \"0.1-SNAPSHOT\"\r\n\r\n#### Maven\r\n    <dependency>\r\n        <groupId>pl.edu.agh.scalamas</groupId>\r\n        <artifactId>emas</artifactId>\r\n        <version>0.1-SNAPSHOT</version>\r\n    </dependency>\r\n\r\nYou can also choose to import only the modules you really need.\r\n\r\n## Getting started\r\n\r\nCreate an object EmasApp, mix-in a stack, emas logic and some genetic operators. Start the application by calling the run\r\n method. Or copy paste the following code:\r\n\r\n    import pl.edu.agh.scalamas.app.{ConcurrentStack, SynchronousEnvironment}\r\n    import pl.edu.agh.scalamas.emas.EmasLogic\r\n    import pl.edu.agh.scalamas.genetic.RastriginProblem\r\n\r\n    import scala.concurrent.duration._\r\n\r\n    object EmasApp extends ConcurrentStack(\"emas\") with SynchronousEnvironment\r\n      with EmasLogic\r\n      with RastriginProblem {\r\n\r\n      def main(args: Array[String]) {\r\n        run(5 seconds)\r\n      }\r\n\r\n    }\r\n\r\nNext, see how to [choose an application stack](#choosing-an-application-stack), write your [own genetic operators](#writing-custom-genetic-operators)\r\nor [customize the multi-agent system](#custom-multi-agent-systems).\r\n\r\n## Usage\r\n\r\nScala-mas uses the Cake Pattern to statically compose a runtime application. You will need two main components: an application stack\r\nand some agent logic. See [here](#choosing-an-application-stack) for choosing the application stack best suited for your runtime environment.\r\nThe stacks also have a run method to start the simulation, with a duration parameter to tell when it should stop.\r\n\r\nScala-mas provides one agent logic implementation as example and primary use-case: Evolutionary Multi-agent Systems (EMAS).\r\nEMAS is an asynchronous evolutionary algorithm used for optimisation. The default implementation will require you to provide yet\r\nanother component representing the genetic operators to use in optimisation. To write your own operators, see [here](#writing-custom-genetic-operators).\r\nTo customize the EMAS logic, see [here](#customizing-the-emas-logic).\r\n\r\nIf you want to implement your own multi-agent simulation, see [here](#custom-multi-agent-systems).\r\n\r\n### Choosing an application stack\r\n\r\nIn order to compose your application, you first need to choose an application stack.\r\nTHe stack will provide the other components of your apps with:\r\n\r\n- runtime configuration\r\n- random number generation\r\n- statistics gathering\r\n\r\nBe sure to use the random number generator provided by the application stack. Otherwise, your application may run into trouble,\r\nfor example math.random is actually synchronised and may quickly become a bottleneck in a concurrent runtime scenario.\r\n\r\nThe following application stack are available:\r\n\r\n- SequentialStack - A sequential, synchronized stack for useful for development and debugging\r\n- ConcurrentStack with SynchronousEnvironment - A concurrent stack with coarse-grained agent concurrency, suited for small numbers of agents or small numbers of cores.\r\n- ConcurrentStack with AsynchronousEnvironment  - A concurrent stack with fine-grained agent concurrency, suited for large numbers of agents\r\nrunning on large numbers of cores\r\n\r\n### Evolutionary Multi-Agent Systems\r\n\r\n#### Writing custom genetic operators\r\n\r\nIn order to use the EMAS app, you need to mix-in some logic responsible for carrying the genetic operations of the underlying evolutionary algorithm.\r\nIn particular, you need to define:\r\n\r\n- The type of solutions to be optimised\r\n- A function to generate initial solutions\r\n- A function to evaluate existing solutions and an ordering for these evaluations (to tell which evaluation is better)\r\n- An unary and binary function to generate new solutions out of existing ones.\r\n\r\nThis functionality is encapsulated in the GeneticOps, GeneticEvaluator and GeneticTransformer traits.\r\nThese traits all take a recursive type parameter to achieve family polimorphism, i.e. to define a set of implementations which can be used together.\r\nYou can implement all these traits in a single class, or compose partial implementations using the Cake Pattern.\r\n\r\nThis EMAS implementation **maximises** the objective function defined by the genetic operators. If you want to minimize instead, just reverse the evaluatiions' ordering.\r\n\r\n#### Customizing the EMAS logic\r\n\r\nThe default EMAS implementation repeatedly group together agents with similar levels of energy. Low energy agents fight, high energy agents reproduce.\r\nBy default, low-energy agents fight by comparing the evaluation of their solutions, winner taking energy from losers.\r\nHigh-energy agents reproduce using the genetic operators and share some energy with their children.\r\nYou can customize these strategies by mixing in custom traits instead of the default ones.\r\n\r\nYou can also fully change the EMAS logic and implement your own multi-agent algorithm by changing the agents behaviours and meetings as described [here](#custom-multi-agent-systems).\r\n\r\n### Custom Multi-Agent Systems\r\n\r\n\r\n## Contributing\r\n\r\nIf you have any suggestions or want to contribute, feel free to open a new ticket or create a pull request.\r\n\r\n## License\r\n\r\nThis project is distributed under the MIT License.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}